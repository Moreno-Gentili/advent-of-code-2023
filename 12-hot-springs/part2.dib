#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!csharp

using System.Text.RegularExpressions;
using System.Collections.Concurrent;
using System.IO;

string[] lines = File.ReadAllLines("input.txt");

ConcurrentDictionary<string, List<int>> matchCache = new();
const bool UseCache = true;

List<Regex> matchers = new(
    from count in Enumerable.Range(0, 20)
    select new Regex(@"(?=(?:\.|\?)(?:#|\?){" + count.ToString() + @"}(?:\.|\?))"));

const int Repetitions = 1;

IEnumerable<int> combinations =
    from line in lines
    let parts = line.Split(' ')
    let pattern = $".{string.Join("?", Enumerable.Repeat(parts[0], Repetitions))}."
    let groups = $"{string.Join(",", Enumerable.Repeat(parts[1], Repetitions))}".Split(',').Select(int.Parse).ToArray()
    select GetCombinations(new Test(pattern, groups, groups.Sum(), 0)
);

// limita il più possibile: se c'è un #, hai già trovato il range
// l'indice successivo non dovrebbe cercare in posizioni precedenti
// metti in cache i frammenti di stringa
// List<int> Groups deve essere un Memory<int>, così che non devi creare nuove liste
HashSet<int> seenGroups = new();
void Log(int group)
{
    if (seenGroups.Add(group))
    {
        System.IO.File.WriteAllText($"logs/{group}.txt", "");
    }
}

int GetCombinations(Test initialTest)
{
    Queue<Test> tests = new();
    tests.Enqueue(initialTest);

    HashSet<string> solutions = new();
    while(tests.Count > 0)
    {
        Test test = tests.Dequeue();
        int group = test.Groups.Span[0];
        Regex matcher = matchers[group];
        Memory<int> nextGroups = test.Groups[1..];
        int nextGroupsSum = test.GroupsSum - group;

        Dictionary<string, int> nextPatterns = new();

        int minimumNeededToComplete = nextGroupsSum + nextGroups.Length - 1;
        int upperBound = test.Pattern.Length - minimumNeededToComplete - 1;
        if (upperBound - test.Offset <= 0) continue; // Sbavatura?
        string subPattern = test.Pattern[test.Offset..upperBound];

        int hashIndex = subPattern.IndexOf('#');
        if (hashIndex >= 0 && hashIndex < (subPattern.Length - 1))
        {
            int maxIndex = Math.Min(subPattern.Length, hashIndex + group);            
            do
            {
                hashIndex++;
            }
            while(hashIndex < maxIndex && subPattern[hashIndex] != '.');

            upperBound = test.Offset + hashIndex + 1;
            subPattern = test.Pattern[test.Offset..upperBound];
        }
        else
        {
        }

        List<int> indexes = null; 
        if (UseCache)
        {
            indexes = matchCache.GetOrAdd($"{group}\t{subPattern}", key => matcher.Matches(subPattern).Cast<Match>().Select(m => m.Index).ToList());
        }
        else
        {
            indexes = matcher.Matches(subPattern).Cast<Match>().Select(m => m.Index).ToList();
        }
        
        foreach (int index in indexes)
        {
            int start = index + test.Offset;
            int length = group + 2;
            int secondPart = Math.Min(test.Pattern.Length, start + length); // Sbavatura Math.Min, andrebbe solo start+length;
            string nextPattern = $"{test.Pattern[0..start]}.{group.ToString().PadRight(group, '.')}.{test.Pattern[secondPart..]}";

            if (nextGroups.Length == 0)
            {
                if (!nextPattern.Contains('#')) // Sbavatura: questo ancora serve, perché?
                {
                    solutions.Add(nextPattern.Replace('?', '.'));
                }
            }
            else
            {
                nextPatterns.TryAdd(nextPattern, start + length - 1);
            }
        }

        foreach (KeyValuePair<string, int> entry in nextPatterns)
        {
            Test nextTest = new Test(entry.Key, nextGroups, nextGroupsSum, entry.Value);
            tests.Enqueue(nextTest);
        }
    }

    return solutions.Count;
}

// Console.WriteLine(string.Join(", ", combinations.AsParallel()));
Console.WriteLine(combinations.AsParallel().Sum());

record Test(string Pattern, Memory<int> Groups, int GroupsSum, int Offset);
